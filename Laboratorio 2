\\ Mux 4:1

design.sv
module mux_4to1_case (a,b,c,d,sel,out);
	parameter N=5;
  input[N-1:0] a,b,c,d;
  input[1:0] sel;
  output reg[N-1:0] out;
  always @ (a or b or c or d or sel) begin
    case (sel)
      2'b00 : out <= a;
      2'b01 : out <= b;
      2'b10 : out <= c;
      2'b11 : out <= d;
    endcase
  end
endmodule
testbench.sv
module tb_4to1_mux;
  parameter N=4; // Bits del mensaje
  reg [N-1:0] a,b,c,d;
  wire [N-1:0] out;
  reg[1:0] sel;
  integer i;

mux_4to1_case #(.N(N))mux0( .a (a),.b (b),.c (c),.d (d),.sel (sel),.out (out));
  initial begin
    
    $monitor ("decimal: sel=%d ,a= %d ,b= %d ,c= %d ,d= %d, out= %d, __________  binario: sel=%b ,a= %b ,b= %b ,c= %b ,d= %b, out= %b  ",sel,a,b,c,d,out, sel,a,b,c,d,out  );
    
    sel =0;// Selección
    a=0; //sel=0  sel=00,
	b=0; //sel=1  sel=01
	c=0; //sel=2  sel=10
	d=0; //sel=3  sel= 11
    
   
    for (i=1; i < 50; i=i+1) begin //Número de pruebas cambiando el 50
      #5 sel =i;
	a=$random;
	b=$random;
	c=$random;
	d=$random;

    end
  	#5 $finish;
  end
endmodule

\\ Cod-deco gray

\\ Sumador Ripple
module SumadorCompleto(a,b,Ci,Sum,Co);
    input a, b,Ci;
    output reg  Sum, Co;
    always @(*)
    begin
    Sum = (a^b^Ci);
    Co = (a&b | b&Ci | Ci&a);
    end

endmodule

module RippleCarryAdder(Sum,Co,a,b,Ci);
    input [7:0] a, b;
    input Ci;
    output [7:0]Sum;
    output Co;
    wire [6:0] carry;
    SumadorCompleto U0(a[0],b[0],Ci,      Sum[0],carry[0]);
    SumadorCompleto U1(a[1],b[1],carry[0],Sum[1],carry[1]);
    SumadorCompleto U2(a[2],b[2],carry[1],Sum[2],carry[2]);
    SumadorCompleto U3(a[3],b[3],carry[2],Sum[3],carry[3]);
    SumadorCompleto U4(a[4],b[4],carry[3],Sum[4],carry[4]);
    SumadorCompleto U5(a[5],b[5],carry[4],Sum[5],carry[5]);
    SumadorCompleto U6(a[6],b[6],carry[5],Sum[6],carry[6]);
    SumadorCompleto U7(a[7],b[7],carry[6],Sum[7],Co);
endmodule
module TestBenchRCA;
    reg [7:0] a, b;
    reg Ci;
    wire [7:0] Sum; 
    wire Co;
    RippleCarryAdder prueba(.Sum(Sum),.Co(Co),.a(a),.b(b),.Ci(Ci));
initial begin 
     a= 8'b00000000; b= 8'b00000000; Ci=1'b0;
    #10 a= 8'b00001001; b= 8'b00000111; Ci=1'b0;
    #10 a= 8'b00000001; b= 8'b00000001; Ci=1'b1;
    #10 a= 8'b11111111; b= 8'b00000001; Ci=1'b0;
    #10 $finish;
end    
endmodule

\\ Alu

\\Carry lookahead adder
module CLA(a,b,Ci,Sum,Co);

parameter Size=32;

input [Size-1:0] a;
input [Size-1:0] b;
input Ci;
output [Size-1:0] Sum;
output Co;

wire [Size-1:0] aa;
wire [Size-1:0] bb;
wire [Size:0] carry;

genvar j,i;
generate 
assign carry[0]=Ci;

for(j=0; j < Size; j=j+1)begin
assign aa[j]=a[j]&b[j];
assign bb[j]=a[j]|b[j];
assign carry[j+1]=aa[j]|(bb[j])&carry[j];

end
assign Co=carry[Size]; 

 for(i = 0; i < Size; i = i+1) begin 
 assign Sum[i] = a[i] ^ b[i] ^ carry[i];
 end
 endgenerate
endmodulemodule CLATestBench();
parameter Size =2;
reg Ci;
reg [Size-1:0] a;
reg [Size-1:0] b;

wire [Size-1:0] Sum;
wire Co;

CLA #(.Size(Size))U1(
       .a(a[Size-1:0]),
       .b(b[Size-1:0]),
       .Ci(Ci),
       .Sum(Sum[Size-1:0]),
       .Co(Co)
       );

initial begin
    a='b11; b='b01; Ci=1'b1;
#10 a='b01; b='b01; Ci=1'b0;
#10 $finish;
end
endmodule

